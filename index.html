<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MOONcake | Mid-Autumn Lucky Page</title>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><circle cx=%2250%22 cy=%2250%22 r=%2240%22 fill=%22%23ffd166%22/></svg>">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">

  <!-- Firebase config -->
  <script>
    window.FIREBASE_CONFIG = {
      apiKey: "AIzaSyD7xOnDHnJdG5p0BoL4UR6gSohuL8a0ncE",
      authDomain: "mooncake-c400c.firebaseapp.com",
      projectId: "mooncake-c400c",
      storageBucket: "mooncake-c400c.appspot.com",
      messagingSenderId: "483605028839",
      appId: "1:483605028839:web:89804c881f445137536742",
      measurementId: "G-29ZD4V0DDJ"
    };
    // ÂèØÈÄâ: Âú®Â§ñÂ±ÇÊ≥®ÂÖ• window.API_BASE Ë¶ÜÁõñÂêéÁ´ØÂüüÂêç
  </script>

  <!-- solana web3 IIFE -->
  <script src="https://unpkg.com/@solana/web3.js@1.95.3/lib/index.iife.min.js"></script>

  <style>
    :root{ --bg:#0a0a0a; --panel:#111; --card:#141414; --text:#f6f7fb; --muted:#b8bbc7; --brand:#ffd166; --line:rgba(255,255,255,.10); --good:#a7f3d0; --warn:#fde68a; --bad:#fca5a5; --pill-bg: rgba(255,209,102,.16) }
    *{box-sizing:border-box} html,body{height:100%}
    body{ margin:0; background: radial-gradient(1200px 600px at 80% -10%, #1a1a1a 0%, #0a0a0a 45%, #000 100%); color:var(--text);
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; font-size:16px; line-height:1.6; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
    a{color:var(--brand);text-decoration:none}
    .container{max-width:980px;margin:0 auto;padding:24px}
    .header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:8px}
    .brand{display:flex;align-items:center;gap:10px}
    .brand .dot{width:10px;height:10px;border-radius:999px;background:var(--brand);box-shadow:0 0 18px var(--brand)}
    .brand h1{margin:0;font-size:14px;font-weight:700;letter-spacing:.3px;color:var(--muted)}
    .wallet{display:flex;align-items:center;gap:10px}
    .btn{ border:1px solid var(--line); background:linear-gradient(180deg,#1b1b1b,#121212); color:var(--text);
      padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700;letter-spacing:.2px; transition:transform .15s ease, box-shadow .2s ease, background .2s ease; }
    .btn:hover{transform:translateY(-1px);box-shadow:0 10px 22px rgba(0,0,0,.35)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn-primary{background:linear-gradient(180deg,#ffd166,#eeb94d);color:#000;border:none}
    .btn-ghost{background:transparent;border:1px solid var(--line);}
    .note{font-size:12px;color:var(--muted)}
    .title-wrap{display:flex;flex-direction:column;align-items:center;gap:8px;margin:22px 0 14px}
    .title-logo{width:64px;height:64px;object-fit:contain;filter:drop-shadow(0 8px 30px rgba(255,209,102,.25))}
    .title{font-size:28px;margin:0;font-weight:800;text-align:center}
    .card{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.01));border:1px solid var(--line);backdrop-filter:blur(6px);border-radius:18px;padding:18px}
    .section{margin:16px 0}.section h2{margin:0 0 10px;font-size:16px}
    .about-list{display:grid;grid-template-columns:1fr;gap:10px;margin:8px 0 0}
    .about-item{display:flex;gap:10px;align-items:flex-start;padding:12px;border:1px solid var(--line);border-radius:14px;background:rgba(255,255,255,.02)}
    .about-item .num{min-width:28px;height:28px;border-radius:9px;background:var(--pill-bg);display:inline-flex;align-items:center;justify-content:center;color:#000;font-weight:800}
    .draw-title{display:flex;align-items:center;gap:8px;margin-bottom:10px}
    .draw-icon{width:28px;height:28px;object-fit:contain}
    .draw{display:grid;grid-template-columns:1fr;gap:10px}
    .stat{display:flex;align-items:center;justify-content:space-between;border:1px dashed var(--line);padding:10px 12px;border-radius:12px;color:var(--muted)}
    .draw-actions{display:flex;gap:10px;flex-wrap:wrap}
    .result{margin-top:8px;padding:12px;border:1px solid var(--line);border-radius:12px;min-height:48px;display:flex;align-items:center}
    #bootError{display:none;margin:8px auto 0;padding:10px 12px;max-width:980px;border:1px solid #ffb4b4;background:#2a1212;color:#ffdada;border-radius:10px;font-size:12px;white-space:pre-wrap}
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;padding:20px;z-index:50}
    .modal.active{display:flex}
    .modal-card{background:#141414;border:1px solid var(--line);border-radius:16px;width:100%;max-width:480px;padding:18px}
    .modal-card h2{margin:0 0 12px;font-size:18px}
    .wallet-list{display:flex;flex-direction:column;gap:10px}
    .wallet-btn{display:flex;align-items:center;gap:10px;width:100%;padding:10px 14px;border:1px solid var(--line);border-radius:12px;background:#1d1d1d;color:#fff;cursor:pointer}
    .wallet-btn:hover{background:#232323}
    .badge{margin-left:auto;font-size:12px;color:var(--muted)}
    .help{font-size:12px;color:var(--muted);margin-top:8px}
    .odds{display:grid;grid-template-columns:1fr;gap:8px;margin-top:8px}
    .odd-row{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border:1px solid var(--line);border-radius:14px;background:rgba(255,255,255,.02)}
    .pill{padding:4px 10px;border-radius:999px;background:var(--pill-bg);color:var(--brand);font-size:12px;font-weight:800}
    .fine{font-size:12px;color:var(--muted)}
    .winners{display:grid;grid-template-columns:1fr;gap:8px}
    .winner-item{display:flex;justify-content:space-between;align-items:center;padding:10px;border:1px solid var(--line);border-radius:12px;background:rgba(255,255,255,.02)}
    .addr{font-family:ui-monospace,Menlo,Consolas,monospace;opacity:.95}
    .prize{font-weight:700}
    .center{text-align:center}.error{color:var(--bad)}
  </style>
</head>
<body>
  <div id="bootError"></div>

  <div class="container">
    <header class="header">
      <div class="brand"><span class="dot"></span><h1>Mid-Autumn</h1></div>
      <div class="wallet">
        <span id="walletLabel" class="note">Not connected</span>
        <button id="connectBtn" class="btn btn-primary">Connect Wallet</button>
        <button id="disconnectBtn" class="btn btn-ghost" title="Disconnect current wallet" style="display:none;">Disconnect</button>
      </div>
    </header>

    <div class="title-wrap">
      <img src="./assets/mooncake.png" alt="MOONcake logo" class="title-logo">
      <h2 class="title">MOONcake</h2>
    </div>

    <p class="center" style="color:var(--muted); margin:4px 0 18px;">
      A tiny lucky page for Solana friends ‚Ä¢ Holders get more chances üçÄ
    </p>

    <!-- About -->
    <section class="section card" id="about">
      <h2>About the Project</h2>
      <div class="about-list">
        <div class="about-item"><div class="num">1</div><p><strong>Full-MOON airdrops.</strong> On every full MOON, we randomly airdrop <em>Lucky Tokens</em> to holders.<br><span class="note">(Snapshot & rules will be announced before each full MOON.)</span></p></div>
        <div class="about-item"><div class="num">2</div><p><strong>Community when ready.</strong> Once a healthy number of holders is reached, we‚Äôll open a Telegram community.<br><span class="note">(We grow sustainably: quality vibes over vanity numbers.)</span></p></div>
        <div class="about-item"><div class="num">3</div><p><strong>Delightful merch drops.</strong> Expect seasonal goodies ‚Äî MOON-themed pieces and playful collabs.<br><span class="note">(Details and claim mechanics will be posted in advance.)</span></p></div>
      </div>
    </section>

    <!-- Draw -->
    <section class="section card" id="draw">
      <div class="draw-title">
        <img src="./assets/happy.png" alt="draw icon" class="draw-icon">
        <h2>Lucky Draw</h2>
      </div>
      <div class="draw">
        <div class="stat"><span>Eligibility</span><span id="eligibility">Chances</span></div>
        <div class="stat"><span>Remaining free (this wallet)</span><span id="remaining">‚Äì</span></div>
        <div class="draw-actions">
          <button id="drawBtn" class="btn" disabled title="Disabled until wallet connects">Draw Now</button>
        </div>
        <div id="result" class="result">Result will appear here ‚ú®</div>
        <p class="note" id="holderNote">Token TBA ‚Äî holder check runs via whitelist until the SPL mint is live.</p>
      </div>
    </section>

    <!-- Odds -->
    <section class="section card" id="draw-info">
      <h2>How it works</h2>
      <div class="tips">
        <div class="ok">‚Ä¢ First draw is <strong id="firstFreeTag">FREE</strong>. After that, each draw costs <strong id="costPerDraw">10,000 tokens</strong>.</div>
        <div>‚Ä¢ Every <strong id="burnEvery">100</strong> draws, we <strong id="burnAmount">burn 100,000 tokens</strong> from the creator treasury.</div>
        <div class="fine">‚Ä¢ Displayed odds are for illustration; actual drawing runs on server rules.</div>
      </div>
      <div class="odds" id="oddsBox">
        <div class="odd-row"><span class="label"><span class="pill">5%</span> MOONcake</span><span class="fine"></span></div>
        <div class="odd-row"><span class="label"><span class="pill">70%</span> Better luck next time</span><span class="fine"></span></div>
        <div class="odd-row"><span class="label"><span class="pill">20%</span> 10k tokens</span><span class="fine"></span></div>
        <div class="odd-row"><span class="label"><span class="pill">3%</span> 50k tokens</span><span class="fine"></span></div>
        <div class="odd-row"><span class="label"><span class="pill">2%‚â§</span> 100k tokens</span><span class="fine"></span></div>
        <div class="odd-row"><span class="label"><span class="pill">1%‚â§</span> Random: 1 SOL / 1 BTC / 1 ETH</span><span class="fine"></span></div>
      </div>
      <p class="fine" style="margin-top:8px;">* UI shows promo odds; real odds are server-side and may adjust dynamically.</p>
    </section>

    <!-- Latest winners -->
    <section class="section card" id="latest-winners">
      <h2>Latest Winners (last 5)</h2>
      <div id="winnersList" class="winners"><div class="fine">Loading‚Ä¶</div></div>
      <p class="fine">Only shows wallet tail & prize for privacy.</p>
    </section>

    <!-- Global counter -->
    <section class="section card" id="moonglow-global">
      <h2>üåï MOONGlow Points (Global)</h2>
      <p class="note">Every visit adds a little more MOONlight ‚Äî this number is shared by everyone ‚ú®</p>
      <div id="moonglowGlobalCounter" class="center" style="font-size:22px;font-weight:800;color:var(--brand)">‚Ä¶</div>
      <div id="moonglowError" class="center error" style="min-height:16px"></div>
    </section>

    <p class="note center" style="margin-top:16px;">
      Welcome anyone with ideas to join us ‚Ä¢ Contact:
      <a href="mailto:mooncakesender@gmail.com">mooncakesender@gmail.com</a>
    </p>
  </div>

  <!-- Wallet modal -->
  <div id="walletModal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
        <h2 id="modalTitle" style="margin:0;">Select a Wallet</h2>
        <button id="refreshWalletsBtn" class="btn btn-ghost">Refresh</button>
      </div>
      <div id="envWarn" class="help"></div>
      <div id="walletList" class="wallet-list" style="margin-top:6px;"></div>
      <div class="help">
        Tip: If MetaMask is installed but shows EVM only, open <b>MetaMask ‚Üí Settings ‚Üí Experimental ‚Üí Enable Solana</b> (or allow the Solana Snap) and return here, then click Refresh.
      </div>
      <button id="closeModalBtn" class="btn" style="width:100%; margin-top:12px">Cancel</button>
    </div>
  </div>

  <!-- Display-only config -->
  <script id="displayConfig" type="application/json">
  {"pricing":{"firstFree":true,"costPerDrawUi":10000},"burn":{"everyDraws":100,"burnAmountUi":100000}}
  </script>

  <!-- Main script -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
    import { getFirestore, doc, getDoc, setDoc, increment, serverTimestamp,
             collection, getDocs, query, orderBy, limit } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-lite.js";

    /* ===== Backend API ===== */
    const API_BASE = (window.API_BASE && String(window.API_BASE)) || "https://mooncake-1.onrender.com";

    /* ===== UI refs ===== */
    const bootErr = document.getElementById('bootError');
    const els = {
      connectBtn: document.getElementById('connectBtn'),
      disconnectBtn: document.getElementById('disconnectBtn'),
      walletLabel: document.getElementById('walletLabel'),
      eligibility: document.getElementById('eligibility'),
      remaining: document.getElementById('remaining'),
      drawBtn: document.getElementById('drawBtn'),
      result: document.getElementById('result'),
      glowGlobal: document.getElementById('moonglowGlobalCounter'),
      glowError: document.getElementById('moonglowError'),
      holderNote: document.getElementById('holderNote'),
      winnersList: document.getElementById('winnersList'),
      modal: document.getElementById('walletModal'),
      walletList: document.getElementById('walletList'),
      closeModalBtn: document.getElementById('closeModalBtn'),
      envWarn: document.getElementById('envWarn'),
      refreshWalletsBtn: document.getElementById('refreshWalletsBtn')
    };
    function showBootError(msg){ bootErr.style.display='block'; bootErr.textContent=msg; console.error('[BOOT]', msg); }

    /* ===== Activity & chain ===== */
    const ACTIVITY_ID = 'mid-autumn-2025';
    const { PublicKey, Transaction, TransactionInstruction, Connection } = window.solanaWeb3;
    const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
    const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");

    const CHAIN = {
      cluster:"mainnet-beta",
      rpcEndpoint:"https://api.mainnet-beta.solana.com",
      commitment:"confirmed",
      mints:[{ address:"", tokenProgram:"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", minHoldUiAmount:0.000001 }],
      decimals:6,
      treasury:null
    };

    const CONFIG_DEFAULT = { holderChances:3, nonHolderChances:1 };
    let PRICE_UI = 10000;

    /* ===== Firebase ===== */
    const app = initializeApp(window.FIREBASE_CONFIG);
    const db  = getFirestore(app);

    /* ===== holder-check ===== */
    let loadRemoteConfig, resolveIsHolder, allowedChances;
    try {
      const m = await import('./holder-check.js');
      loadRemoteConfig = m.loadRemoteConfig;
      resolveIsHolder  = m.resolveIsHolder;
      allowedChances   = m.allowedChances;
    } catch {
      loadRemoteConfig = async () => ({ ...CONFIG_DEFAULT });
      resolveIsHolder  = async () => false;
      allowedChances   = (isHolder, cfg) => isHolder ? (cfg?.holderChances ?? 3) : (cfg?.nonHolderChances ?? 1);
    }
    async function safeResolveIsHolder({ db, address, chainConfig, config, timeoutMs = 2000 }) {
      const isSol = typeof address === 'string' && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address) && !address.startsWith('0x');
      if (!isSol || typeof resolveIsHolder !== 'function') return false;
      try {
        const p = resolveIsHolder({ db, address, chainConfig, config });
        const t = new Promise((_, rej) => setTimeout(() => rej(new Error('holder-check-timeout')), timeoutMs));
        return await Promise.race([p, t]).catch(() => false);
      } catch { return false; }
    }

    /* ===== State & helpers ===== */
    let walletAddress = null;
    let walletType = null;
    let currentProvider = null;

    const short = (addr)=> addr ? (addr.startsWith('0x') ? addr.slice(0,6)+'‚Ä¶'+addr.slice(-4): addr.slice(0,4)+'‚Ä¶'+addr.slice(-4)) : '';
    const tail  = (addr,n=4)=> addr ? '‚Ä¶'+String(addr).slice(-n) : '';
    const partDoc = (address)=> doc(db,'activities',ACTIVITY_ID,'participants',String(address).toLowerCase());
    const localKey= (addr)=> `draw:${ACTIVITY_ID}:${String(addr).toLowerCase()}`;
    const readUsedLocal =(addr)=>{ try{ return Number(JSON.parse(localStorage.getItem(localKey(addr)))?.used||0);}catch{return 0;} };
    const writeUsedLocal=(addr,used)=> localStorage.setItem(localKey(addr), JSON.stringify({used,ts:Date.now()}));
    const isSolanaAddress = (addr)=> typeof addr==='string' && !addr.startsWith('0x') && /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(addr);
    const isSolanaCapableProvider = (p)=> !!p && (typeof p.signAndSendTransaction==='function' || typeof p.signTransaction==='function');

    function allowedChancesLocal(isHolder,cfg){ return allowedChances(isHolder,cfg); }
    async function ensureParticipant(address,isHolder,cfg){
      try{
        const ref = partDoc(address);
        const snap = await getDoc(ref);
        if (!snap.exists()){
          await setDoc(ref,{ address:String(address).toLowerCase(), isHolder, used:0, allowed:allowedChancesLocal(isHolder,cfg),
            createdAt:serverTimestamp(), updatedAt:serverTimestamp(), walletType }, { merge:true });
        }
      }catch(e){ console.warn('ensureParticipant warn:', e); }
    }
    async function readUsedFS(address){ try{ const s=await getDoc(partDoc(address)); return s.exists()?Number(s.data().used||0):0; }catch{return 0;} }
    async function writeUsedFS(address,used,lastPrize=null,isHolder=false,cfg=CONFIG_DEFAULT){
      try{ await setDoc(partDoc(address),{ address:String(address).toLowerCase(), isHolder, used, allowed:allowedChancesLocal(isHolder,cfg), lastPrize, updatedAt:serverTimestamp(), walletType },{merge:true}); }
      catch(e){ console.warn('writeUsedFS warn:', e); }
    }

    async function computeRemaining(address,isHolder,cfg){
      try{
        const usedFS=await readUsedFS(address);
        const usedLocal=readUsedLocal(address);
        const used=Math.max(usedFS,usedLocal);
        if (used>usedFS) await writeUsedFS(address,used,null,isHolder,cfg);
        const allowed = allowedChancesLocal(isHolder,cfg);
        const rem = Math.max(0, allowed - used);
        console.log('[draw] allowed=%s used=%s rem=%s', allowed, used, rem);
        return { freeLeft: rem, usedSoFar: used, allowed };
      }catch(e){ console.warn('computeRemaining failed:', e); return { freeLeft:0, usedSoFar:0, allowed:0 }; }
    }

    async function updateUI(isHolder=false,cfg=CONFIG_DEFAULT){
      els.walletLabel.textContent = walletAddress ? `${short(walletAddress)}${walletType?' ¬∑ '+walletType:''}` : 'Not connected';
      els.disconnectBtn.style.display = walletAddress ? 'inline-flex' : 'none';

      if (!walletAddress){
        els.remaining.textContent='‚Äì';
        els.drawBtn.disabled=true;
        els.drawBtn.title='Disabled: no wallet connected';
        els.eligibility.textContent='Chances: ‚Äì';
        return;
      }

      const { freeLeft } = await computeRemaining(walletAddress,isHolder,cfg);
      els.remaining.textContent = String(freeLeft);

      // ‚úÖ ÂÖçË¥πÁî®Â∞ΩÂêé‰ªçÂÖÅËÆ∏ÁÇπÂáªÔºåËøõÂÖ•‰ªòË¥πÊäΩ
      els.drawBtn.disabled = false;
      els.drawBtn.title = freeLeft<=0
        ? `No free chances ¬∑ Paid draw costs ${PRICE_UI.toLocaleString()} tokens`
        : 'Free draw available';

      els.eligibility.textContent = `Free chances left: ${freeLeft}`;
      const hasMint = Array.isArray(CHAIN.mints)&&CHAIN.mints[0]?.address; els.holderNote.style.display = hasMint?'none':'block';
    }

    /* ===== ÁéØÂ¢ÉÊèêÁ§∫ ===== */
    function envCheck(){
      const tips=[];
      const httpsOk = location.protocol==='https:' || location.hostname==='localhost' || location.hostname==='127.0.0.1';
      if(!httpsOk) tips.push('Use HTTPS (or localhost).');
      if(window.top!==window.self) tips.push('Open in a top-level tab (not in an iframe).');
      return tips.join(' ');
    }

    /* ===== Èí±ÂåÖÊ£ÄÊµã ===== */
    function detectPhantom(){ return (window.solana?.isPhantom ? window.solana : (window.phantom?.solana?.isPhantom ? window.phantom.solana : null)); }
    function detectSolflare(){ return (window.solflare || null); }
    function detectBackpack(){ return (window.backpack?.solana?.isBackpack ? window.backpack.solana : null); }
    function detectOKX(){ return (window.okxwallet?.solana || null); }
    function detectMagicEden(){ return (window.magicEden?.solana || null); }
    function getMetaMaskProvider(){
      const eth = window.ethereum; if(!eth) return null;
      if (eth.isMetaMask) return eth;
      if (Array.isArray(eth.providers)) return eth.providers.find(p => p && p.isMetaMask) || null;
      return null;
    }
    function getInjectedMetaMaskSolana(){ if (window.solana?.isMetaMask) return window.solana; if (window.metamask?.solana) return window.metamask.solana; return null; }
    async function getInstalledSnaps(){
      const mm = getMetaMaskProvider(); if(!mm) return {};
      try { return await mm.request({ method:'wallet_getSnaps' }); } catch { return {}; }
    }
    function pickSolanaSnapIdFrom(snaps){ for (const s of Object.values(snaps || {})) { if (/solana/i.test(s?.id || '')) return s.id; } return null; }
    async function invokeSnap(snapId, method, params = {}){
      const mm = getMetaMaskProvider(); if(!mm) throw new Error('MetaMask not detected');
      try { return await mm.request({ method:'wallet_invokeSnap', params:{ snapId, request:{ method, params } } }); }
      catch { return await mm.request({ method:'wallet_invokeSnap', params:[snapId, { method, params }] }); }
    }
    async function connectMetaMaskEVM(){
      const mm = getMetaMaskProvider(); if(!mm) throw new Error('MetaMask not detected');
      const accounts = await mm.request({ method:'eth_requestAccounts' });
      const addr = accounts?.[0]; if(!addr) throw new Error('No EVM account');
      currentProvider = null; return { address:String(addr), label:'MetaMask (EVM)' };
    }
    async function connectMetaMaskSolana(){
      const mm = getMetaMaskProvider(); if(!mm) throw new Error('MetaMask not detected');
      const injected = getInjectedMetaMaskSolana();
      if (injected){ return await connectSolanaProvider('MetaMask (Solana)', injected); }
      try{
        const snaps = await getInstalledSnaps(); const snapId = pickSolanaSnapIdFrom(snaps);
        if (snapId){
          const methods = ['getAccounts','getAccount','solana_getAccounts']; let accounts=null,lastErr=null;
          for (const m of methods){ try{ const r = await invokeSnap(snapId,m); if(r){ accounts=r; break; } }catch(e){ lastErr=e; } }
          if (!accounts) throw lastErr || new Error('No accounts from Solana Snap');
          let addr=null; if (Array.isArray(accounts) && accounts.length){ const first=accounts[0]; addr = typeof first==='string' ? first : (first?.address||first?.publicKey||null); }
          else if (typeof accounts==='string'){ addr = accounts; }
          if (!addr) throw new Error('Unable to read Solana address');
          currentProvider = null; return { address:String(addr), label:'MetaMask (Solana ¬∑ Snap)' };
        }
      }catch{}
      return await connectMetaMaskEVM();
    }

    const WALLET_DEFS = [
      { key:'phantom',   label:'Phantom',    detect:()=>detectPhantom(),   install:'https://phantom.app/' },
      { key:'solflare',  label:'Solflare',   detect:()=>detectSolflare(),  install:'https://solflare.com/' },
      { key:'backpack',  label:'Backpack',   detect:()=>detectBackpack(),  install:'https://backpack.app/' },
      { key:'okx',       label:'OKX Wallet', detect:()=>detectOKX(),       install:'https://www.okx.com/web3' },
      { key:'magiceden', label:'Magic Eden', detect:()=>detectMagicEden(), install:'https://magiceden.io/wallet' },
      { key:'metamask',  label:'MetaMask',   detect:'metamask',            install:'https://metamask.io/' }
    ];

    function providerConnectButton(label, provider){
      const btn = document.createElement('button');
      btn.className = 'wallet-btn';
      btn.innerHTML = `<span>üí†</span><span>${label}</span><span class="badge">Detected</span>`;
      btn.addEventListener('click', ()=> connectSolanaProvider(label, provider));
      return btn;
    }

    async function renderWalletList(){
      els.envWarn.textContent = envCheck();
      els.walletList.innerHTML = '';

      for (const def of WALLET_DEFS){
        if (def.detect === 'metamask'){
          const hasMM = !!getMetaMaskProvider();
          const btn = document.createElement('button');
          btn.className = 'wallet-btn';

          if (!hasMM){
            btn.innerHTML = `<span>ü¶ä</span><span>${def.label}</span><span class="badge">Not installed</span>`;
            btn.addEventListener('click', ()=> window.open(def.install,'_blank'));
          } else {
            let badge = 'EVM only';
            try{
              if (getInjectedMetaMaskSolana()) badge = 'Solana';
              else { const snaps = await getInstalledSnaps(); if (pickSolanaSnapIdFrom(snaps)) badge = 'Solana (Snap)'; }
            }catch{}
            btn.innerHTML = `<span>ü¶ä</span><span>${def.label}</span><span class="badge">${badge}</span>`;

            btn.addEventListener('click', async ()=>{
              try{
                const res = await connectMetaMaskSolana();
                walletAddress = res.address;
                walletType    = res.label;
                hideModal();

                await updateUI(false, CONFIG_DEFAULT);

                const cfg = await loadRemoteConfig(db, { defaults: CONFIG_DEFAULT }) ?? { ...CONFIG_DEFAULT };
                const isSol = isSolanaAddress(walletAddress);
                const isHolder = isSol ? await safeResolveIsHolder({ db, address: walletAddress, chainConfig: CHAIN, config: cfg }) : false;

                await ensureParticipant(walletAddress, isHolder, cfg);
                await updateUI(isHolder, cfg);
              }catch(e){
                console.error('[MetaMask] connect failed:', e);
                alert('MetaMask connect failed: ' + (e?.message||e));
              }
            });
          }
          els.walletList.appendChild(btn);
          continue;
        }

        const provider = def.detect();
        if (provider){ els.walletList.appendChild(providerConnectButton(def.label, provider)); }
        else {
          const btn = document.createElement('button');
          btn.className = 'wallet-btn';
          btn.innerHTML = `<span>üí†</span><span>${def.label}</span><span class="badge">Not installed</span>`;
          btn.addEventListener('click', ()=> window.open(def.install,'_blank'));
          els.walletList.appendChild(btn);
        }
      }
    }

    function showModal(){ renderWalletList(); els.modal.classList.add('active'); els.modal.setAttribute('aria-hidden','false'); }
    function hideModal(){ els.modal.classList.remove('active'); els.modal.setAttribute('aria-hidden','true'); }
    els.connectBtn.addEventListener('click', showModal);
    els.closeModalBtn.addEventListener('click', hideModal);
    els.refreshWalletsBtn.addEventListener('click', renderWalletList);

    async function connectSolanaProvider(label, provider){
      try{
        let resp=null; try{ resp = await provider.connect?.({ onlyIfTrusted:true }); }catch{}
        if(!resp && provider.connect) resp = await provider.connect();

        const pk = resp?.publicKey || provider.publicKey || resp?.accounts?.[0];
        if(!pk) throw new Error('No publicKey from wallet');

        const address =
          (pk && typeof pk.toBase58 === 'function') ? pk.toBase58() :
          (typeof pk === 'string') ? pk : String(pk);

        walletAddress = address;
        walletType    = label;
        currentProvider = provider;
        hideModal();

        await updateUI(false, CONFIG_DEFAULT);

        const cfg = await loadRemoteConfig(db, { defaults: CONFIG_DEFAULT }) ?? { ...CONFIG_DEFAULT };
        const isHolder = await safeResolveIsHolder({ db, address: walletAddress, chainConfig: CHAIN, config: cfg });
        await ensureParticipant(walletAddress, isHolder, cfg);
        await updateUI(isHolder, cfg);
      }catch(e){
        console.error(`[${label}] connect error:`, e);
        alert(`${label} connect failed: ${e?.message || e}`);
      }
    }

    /* ===== Disconnect ===== */
    els.disconnectBtn.addEventListener('click', async ()=>{
      walletAddress=null; walletType=null; currentProvider=null;
      await updateUI(false, CONFIG_DEFAULT);
    });

    /* ===== ÂêéÁ´ØÈÖçÁΩÆÂä†ËΩΩÔºàÊîØÊåÅ /status ‰∏é /configÔºâ ===== */
    function pickFrontendRpc(url){
      if (!url) return 'https://solana.publicnode.com';
      return url;
    }
    async function loadServerChain(){
      try{
        // ‚ë† /status ‰ºòÂÖà
        try{
          const r1 = await fetch(`${API_BASE}/status`,{headers:{'Accept':'application/json'}, cache:'no-store'});
          if (r1.ok){
            const s = await r1.json();
            if (s?.mint) CHAIN.mints[0].address = s.mint;
            if (typeof s?.decimals === 'number') CHAIN.decimals = s.decimals;
            if (s?.treasury) CHAIN.treasury = s.treasury;
            if (s?.rpc) CHAIN.rpcEndpoint = pickFrontendRpc(s.rpc);
            if (typeof s?.costUi === 'number') PRICE_UI = s.costUi;
          }
        }catch{}

        // ‚ë° /config ÂÖúÂ∫ïÔºàÊúâÁöÑÂêéÁ´ØÊòØÂåÖÂú® config ÈáåÔºâ
        try{
          const r=await fetch(`${API_BASE}/config`,{headers:{'Accept':'application/json'}, cache:'no-store'});
          if (r.ok){
            const j=await r.json();
            const c = j?.config || j;
            if (c?.mint) CHAIN.mints[0].address = c.mint;
            if (typeof c?.decimals === 'number') CHAIN.decimals = c.decimals;
            if (typeof c?.mintDecimals === 'number') CHAIN.decimals = c.mintDecimals; // ÂÖºÂÆπÂ≠óÊÆµ
            if (c?.treasury) CHAIN.treasury = c.treasury;
            if (c?.rpc) CHAIN.rpcEndpoint = pickFrontendRpc(c.rpc);
            if (typeof c?.price === 'number') PRICE_UI = c.price;
            if (typeof c?.drawCostUi === 'number') PRICE_UI = c.drawCostUi; // ÂÖºÂÆπÂ≠óÊÆµ
          }
        }catch{}

        // UI ÊèêÁ§∫
        if (!CHAIN.mints[0].address || !CHAIN.treasury){
          showBootError('Backend not fully configured: missing mint or treasury. Free draw only.');
        }
        const costNode = document.getElementById('costPerDraw');
        if (costNode) costNode.textContent = `${PRICE_UI.toLocaleString()} tokens`;

        console.log('[chain]', {
          rpc: CHAIN.rpcEndpoint,
          mint: CHAIN.mints[0].address,
          decimals: CHAIN.decimals,
          treasury: CHAIN.treasury,
          price: PRICE_UI
        });
      }catch(e){
        console.warn('loadServerChain warn:', e);
        showBootError('Failed to load backend config. You can still do the free first draw after connecting a wallet.');
      }
    }

    /* ===== RPC Â∑•ÂÖ∑ ===== */
    const PUBLIC_RPCS = [
      'https://solana.publicnode.com',
      'https://solana-rpc.publicnode.com',
      'https://api.mainnet-beta.solana.com'
    ];
    function buildRpcList(primary){
      const list = [];
      if (primary) list.push(primary);
      list.push(...PUBLIC_RPCS);
      const seen=new Set(); return list.filter(u=>{const k=(u||'').trim(); if(!k||seen.has(k)) return false; seen.add(k); return true;});
    }
    function isApiKeyErr(err){ const s=String(err?.message||err||''); return /-32052|api key|forbidden|403/i.test(s); }
    function withTimeout(p,ms=2500){ return Promise.race([p,new Promise((_,rej)=>setTimeout(()=>rej(new Error('rpc-timeout')),ms))]); }

    /* ===== SPL Transfer Helpers ===== */
    function u64LE(nBig){ const b = new Uint8Array(8); let x = BigInt(nBig); for (let i=0;i<8;i++){ b[i] = Number(x & 0xffn); x >>= 8n; } return b; }
    function deriveATA(ownerPk, mintPk){
      return PublicKey.findProgramAddressSync([ ownerPk.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mintPk.toBuffer() ], ASSOCIATED_TOKEN_PROGRAM_ID)[0];
    }
    function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals){
      const data = new Uint8Array(1 + 8 + 1);
      data[0] = 12; data.set(u64LE(BigInt(amount)), 1); data[1+8] = Number(decimals);
      const keys = [
        { pubkey: source,      isSigner:false, isWritable:true  },
        { pubkey: mint,        isSigner:false, isWritable:false },
        { pubkey: destination, isSigner:false, isWritable:true  },
        { pubkey: owner,       isSigner:true,  isWritable:false }
      ];
      return new TransactionInstruction({ keys, programId: TOKEN_PROGRAM_ID, data });
    }
    async function signAndSendViaWallet(tx){
      const res = await currentProvider.signAndSendTransaction(tx);
      return res?.signature || res;
    }
    async function sendSplTransferChecked({ provider, fromAddress, toOwnerAddress, mintAddress, amountUi, decimals }){
      if(!provider) throw new Error('No Solana provider available');

      const fromOwner = new PublicKey(fromAddress);
      const toOwner   = new PublicKey(toOwnerAddress);
      const mintPk    = new PublicKey(mintAddress);

      const fromATA = deriveATA(fromOwner, mintPk);
      const toATA   = deriveATA(toOwner, mintPk);
      const amount  = (BigInt(Math.trunc(amountUi)) * (10n ** BigInt(decimals)));

      const tx = new Transaction();
      tx.add(createTransferCheckedInstruction(fromATA, mintPk, toATA, fromOwner, amount, decimals));

      // Â∞ùËØïÁõ¥Êé•Ëµ∞Èí±ÂåÖÔºàÈÉ®ÂàÜÈí±ÂåÖ‰ºöËá™Âä®Ë°• blockhashÔºâ
      if (typeof provider.signAndSendTransaction === 'function'){
        try {
          const sig = await signAndSendViaWallet(tx);
          return String(sig);
        } catch (e) {
          const msg = String(e?.message||e||'');
          if (!/blockhash/i.test(msg) && !/recent/i.test(msg)) throw e;
        }
      }

      // Êàë‰ª¨Ë°• blockhash & feePayerÔºåÂÜçÊ¨°Â∞ùËØï
      const rpclist = buildRpcList(CHAIN.rpcEndpoint);
      let lastErr = null;

      for (const endpoint of rpclist) {
        try {
          const conn = new Connection(endpoint, CHAIN.commitment);
          const { blockhash, lastValidBlockHeight } = await withTimeout(conn.getLatestBlockhash(CHAIN.commitment), 2500);
          tx.recentBlockhash = blockhash;
          tx.feePayer = fromOwner;

          let sig;
          if (typeof provider.signAndSendTransaction === 'function'){
            const res = await provider.signAndSendTransaction(tx);
            sig = res?.signature || res;
          } else if (typeof provider.signTransaction === 'function'){
            const signed = await provider.signTransaction(tx);
            const raw = signed.serialize();
            sig = await withTimeout(conn.sendRawTransaction(raw, { skipPreflight:false }), 4000);
            await withTimeout(conn.confirmTransaction({ signature: sig, blockhash, lastValidBlockHeight }, CHAIN.commitment), 6000);
          } else {
            throw new Error('Wallet cannot send transaction; please use Phantom/Solflare/Backpack.');
          }
          return String(sig);
        } catch (err) {
          lastErr = err;
          if (isApiKeyErr(err)) { console.warn('[send] RPC key/403, switch next:', endpoint); continue; }
          console.warn('[send] RPC error, try next:', endpoint, err);
          continue;
        }
      }
      throw lastErr || new Error('all rpc failed');
    }

    /* ===== DRAWÔºàÂê´Êâ£Ê¨æÔºâ ===== */
    async function performDraw(){
      if(!walletAddress) return;

      const cfg = await loadRemoteConfig(db,{defaults:CONFIG_DEFAULT});
      const isSol = isSolanaAddress(walletAddress);
      const isHolder = isSol ? await safeResolveIsHolder({ db, address: walletAddress, chainConfig: CHAIN, config: cfg }) : false;

      const remInfo = await computeRemaining(walletAddress,isHolder,cfg);
      const freeLeft = remInfo.freeLeft;
      const usedSoFar = remInfo.usedSoFar;
      const allowedFree = remInfo.allowed;

      // ÂÖ≥ÈîÆÔºöÂÖçË¥πÁî®Â∞ΩÂêé‰∏ç returnÔºåËÄåÊòØËøõÂÖ•‰ªòË¥πÈÄªËæë
      const needPay = freeLeft <= 0;

      if (needPay){
        if (!isSol) { els.result.textContent='Please connect a Solana wallet for paid draws.'; return; }
        if (!isSolanaCapableProvider(currentProvider)) {
          els.result.textContent='Current wallet cannot sign Solana transactions. Please use Phantom/Solflare/Backpack/etc.';
          return;
        }
        if (!CHAIN.mints?.[0]?.address || !CHAIN.treasury){
          els.result.textContent='Payment not configured. Please try again later.';
          console.warn('Missing mint/treasury from backend /config or /status');
          return;
        }
      }

      els.drawBtn.disabled=true;
      els.result.textContent= needPay ? `Paying ${PRICE_UI.toLocaleString()}‚Ä¶ ‚è≥` : 'Drawing‚Ä¶ ‚ú®';

      try{
        let paySig = null;

        if (needPay){
          const sig = await sendSplTransferChecked({
            provider: currentProvider,
            fromAddress: walletAddress,
            toOwnerAddress: CHAIN.treasury,
            mintAddress: CHAIN.mints[0].address,
            amountUi: PRICE_UI,
            decimals: CHAIN.decimals ?? 6
          });
          paySig = String(sig);
          els.result.textContent = 'Payment confirmed. Drawing‚Ä¶ ‚ú®';
        }

        const r = await fetch(`${API_BASE}/draw`, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ wallet: walletAddress, clientSeed: crypto.randomUUID(), paySig: paySig || null })
        });
        const data = await r.json().catch(()=>null);
        if(!r.ok || !data?.ok) throw new Error(data?.error || `HTTP ${r.status}`);

        const prize = data.prize?.label || 'Prize';
        els.result.textContent = `You got: ${prize} ‚ú®`;

        // ‰ΩøÁî®ËÆ°Êï∞ÔºöÂÖçË¥πÊàñ‰ªòË¥πÈÉΩ +1
        const usedNow = usedSoFar + 1;
        writeUsedLocal(walletAddress, usedNow);
        await writeUsedFS(walletAddress, usedNow, prize, isHolder, cfg);
      }catch(e){
        console.error('draw error:', e);
        els.result.textContent = `Draw failed: ${e?.message || e}`;
      }finally{
        const cfg2 = await loadRemoteConfig(db,{defaults:CONFIG_DEFAULT});
        const isHolder2 = isSol ? await safeResolveIsHolder({ db, address: walletAddress, chainConfig: CHAIN, config: cfg2 }) : false;
        await updateUI(isHolder2, cfg2);
      }
    }

    els.drawBtn.addEventListener('click', performDraw);

    /* ===== MOONGlow ===== */
    const glowRef = doc(db, 'stats', 'moonglow');
    async function ensureGlow(){ const s=await getDoc(glowRef); if(!s.exists()){ await setDoc(glowRef,{ total:0, updatedAt:serverTimestamp() },{merge:true}); } }
    async function incGlowOnce(){ await setDoc(glowRef,{ total:increment(1), updatedAt:serverTimestamp() },{merge:true}); }
    async function readGlow(){ const s=await getDoc(glowRef); return s.exists()?Number(s.data().total||0):0; }
    async function updateGlowUIWithRetry(){
      els.glowError.textContent=''; els.glowGlobal.textContent='‚Ä¶';
      try{ await ensureGlow(); await incGlowOnce(); els.glowGlobal.textContent=String(await readGlow()); }
      catch(e){ console.error('[MOONGlow] failed:', e); els.glowGlobal.textContent='‚Äî'; els.glowError.textContent='Global counter failed.'; }
    }

    /* ===== Winners ===== */
    async function fetchLatestWinners(){
      try{
        const r=await fetch(`${API_BASE}/draws/latest?limit=5`,{headers:{'Accept':'application/json'}});
        if(r.ok){
          const j=await r.json();
          if(j?.ok && Array.isArray(j.draws)){
            const a=j.draws.map(x=>({address:x.wallet||x.address, prizeLabel:x.prizeLabel||(x.prize&&x.prize.label), type:(x.type||'').toUpperCase()}))
                           .filter(it=>it.type && it.type!=='NONE');
            if(a.length) return a.slice(0,5);
          }
        }
      }catch(_){}
      try{
        const drawsColl = collection(db,'activities',ACTIVITY_ID,'draws');
        const qSnap = await getDocs(query(drawsColl, orderBy('timestamp','desc'), limit(20)));
        const items = (qSnap?.docs||[]).map(d=>({id:d.id,...d.data()}));
        return items.map(d=>({address:d.wallet||d.address, prizeLabel:d.prizeLabel||(d.prize&&d.prize.label), type:(d.type||'').toUpperCase()}))
                    .filter(it=>it.address && it.type!=='NONE').slice(0,5);
      }catch(e){ console.error('[Winners] read failed:', e); return null; }
    }
    function renderWinners(list){
      const box=els.winnersList;
      if(!Array.isArray(list)||!list.length){ box.innerHTML='<div class="fine">No winners yet.</div>'; return; }
      box.innerHTML='';
      list.forEach(w=>{
        const li=document.createElement('div');
        li.className='winner-item';
        li.innerHTML=`<span class="addr">${tail(w.address||'',4)}</span><span class="prize">${w.prizeLabel||'Prize'}</span>`;
        box.appendChild(li);
      });
    }
    async function updateWinnersUI(){ els.winnersList.innerHTML='<div class="fine">Loading‚Ä¶</div>'; const list=await fetchLatestWinners(); renderWinners(list||[]); }

    /* ===== Boot ===== */
    const tips = envCheck(); if(tips) console.warn('[ENV]', tips);
    await loadServerChain();
    await updateGlowUIWithRetry();
    await updateUI(false, CONFIG_DEFAULT);
    await updateWinnersUI();
  </script>
</body>
</html>
















